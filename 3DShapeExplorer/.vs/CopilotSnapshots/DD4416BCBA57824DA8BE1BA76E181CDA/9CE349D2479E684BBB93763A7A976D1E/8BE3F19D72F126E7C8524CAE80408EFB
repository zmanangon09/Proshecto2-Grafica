using System;
using System.Collections.Generic;
using System.Windows.Forms;
using _3D_SHAPE_EXPLORER.Models;

namespace _3D_SHAPE_EXPLORER.Services
{
    public class KeyboardController
    {
        private readonly Timer timer = new Timer();
        private readonly HashSet<Keys> keys = new HashSet<Keys>();
        private readonly Control targetCanvas;
        private readonly SceneManager sceneManager;
        private readonly Form parentForm;

        private const float RotationStep = 2f;
        private const float ScaleStep = 0.05f;
        private const float TranslationStep = 2f;

        public event Action<string> OnStatusChanged;
        public event Action OnF6Pressed;

        public KeyboardController(Form form, Control canvas, SceneManager manager)
        {
            sceneManager = manager;
            targetCanvas = canvas;
            parentForm = form;

            // Ensure form captures keys before child controls
            form.KeyPreview = true;

            form.KeyDown += (s, e) =>
            {
                // Agregar tecla al conjunto para procesamiento continuo
                if (!keys.Contains(e.KeyCode)) keys.Add(e.KeyCode);
                
                // Manejar teclas especiales
                HandleSpecialKeys(e);
                
                // Suprimir teclas de navegación para evitar que cambien el foco
                if (IsNavigationKey(e.KeyCode))
                {
                    e.Handled = true;
                }
            };

            form.KeyDown += HandleDeleteKey;

            form.KeyUp += (s, e) =>
            {
                if (keys.Contains(e.KeyCode)) keys.Remove(e.KeyCode);
            };

            // Timer for fluid movement (approx 60 FPS)
            timer.Interval = 16;
            timer.Tick += (s, e) => UpdateTransformations();
            timer.Start();
        }

        /// <summary>
        /// Verifica si una tecla es una tecla de navegación que podría mover el foco
        /// </summary>
        private bool IsNavigationKey(Keys key)
        {
            return key == Keys.Up || key == Keys.Down || 
                   key == Keys.Left || key == Keys.Right;
        }

        public void RefocusCanvas()
        {
            // Primero el formulario, luego el canvas
            parentForm.Focus();
            targetCanvas.Focus();
        }

        private void HandleSpecialKeys(KeyEventArgs e)
        {
            switch (e.KeyCode)
            {
                case Keys.F1: 
                    sceneManager.Camera.SetFrontView(); 
                    OnStatusChanged?.Invoke("View: Front"); 
                    e.Handled = true;
                    break;
                case Keys.F2: 
                    sceneManager.Camera.SetTopView(); 
                    OnStatusChanged?.Invoke("View: Top"); 
                    e.Handled = true;
                    break;
                case Keys.F3: 
                    sceneManager.Camera.SetRightView(); 
                    OnStatusChanged?.Invoke("View: Right"); 
                    e.Handled = true;
                    break;
                case Keys.F4: 
                    sceneManager.Camera.SetLeftView(); 
                    OnStatusChanged?.Invoke("View: Left"); 
                    e.Handled = true;
                    break;
                case Keys.F5: 
                    sceneManager.Camera.SetIsometricView(); 
                    OnStatusChanged?.Invoke("View: Perspective"); 
                    e.Handled = true;
                    break;
                case Keys.F6:
                    OnF6Pressed?.Invoke();
                    e.Handled = true;
                    e.SuppressKeyPress = true;
                    break;
                case Keys.Home: 
                    sceneManager.Camera.Reset(); 
                    OnStatusChanged?.Invoke("Camera Reset"); 
                    e.Handled = true;
                    break;
            }
            
            // Redibujar para las teclas de función
            if (e.KeyCode >= Keys.F1 && e.KeyCode <= Keys.F5 || e.KeyCode == Keys.Home)
            {
                targetCanvas.Invalidate();
            }
        }

        private void UpdateTransformations()
        {
            bool needsRedraw = false;

            // 1. CAMERA CONTROLS
            if (keys.Contains(Keys.Left)) { sceneManager.Camera.RotateLeft(); needsRedraw = true; }
            if (keys.Contains(Keys.Right)) { sceneManager.Camera.RotateRight(); needsRedraw = true; }
            if (keys.Contains(Keys.Up)) { sceneManager.Camera.RotateUp(); needsRedraw = true; }
            if (keys.Contains(Keys.Down)) { sceneManager.Camera.RotateDown(); needsRedraw = true; }

            // Zoom
            if (keys.Contains(Keys.Add) || keys.Contains(Keys.Oemplus)) { sceneManager.Camera.ZoomIn(); needsRedraw = true; }
            if (keys.Contains(Keys.Subtract) || keys.Contains(Keys.OemMinus)) { sceneManager.Camera.ZoomOut(); needsRedraw = true; }

            // 2. SHAPE CONTROLS
            Shape3D selectedShape = sceneManager.Shapes.Find(s => s.IsSelected);
            if (selectedShape != null)
            {
                bool subObjectTransformed = false;

                // Sub-object logic
                if (sceneManager.SelectedVertexIndex.HasValue)
                {
                    ApplyTransformationToPoint(selectedShape.OriginalPoints[sceneManager.SelectedVertexIndex.Value]);
                    subObjectTransformed = true;
                }
                else if (sceneManager.SelectedEdge != null)
                {
                    ApplyTransformationToPoint(selectedShape.OriginalPoints[sceneManager.SelectedEdge.Item1]);
                    ApplyTransformationToPoint(selectedShape.OriginalPoints[sceneManager.SelectedEdge.Item2]);
                    subObjectTransformed = true;
                }
                else if (sceneManager.SelectedFace != null)
                {
                    foreach (var idx in sceneManager.SelectedFace) ApplyTransformationToPoint(selectedShape.OriginalPoints[idx]);
                    subObjectTransformed = true;
                }

                // Full Object logic
                if (!subObjectTransformed)
                {
                    // Rotation
                    // X Axis
                    if (keys.Contains(Keys.NumPad4) || keys.Contains(Keys.T)) { selectedShape.RotationX -= RotationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.NumPad6) || keys.Contains(Keys.G)) { selectedShape.RotationX += RotationStep; needsRedraw = true; }
                    // Y Axis
                    if (keys.Contains(Keys.NumPad8) || keys.Contains(Keys.F)) { selectedShape.RotationY -= RotationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.NumPad2) || keys.Contains(Keys.H)) { selectedShape.RotationY += RotationStep; needsRedraw = true; }
                    // Z Axis
                    if (keys.Contains(Keys.A)) { selectedShape.RotationZ -= RotationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.D)) { selectedShape.RotationZ += RotationStep; needsRedraw = true; }

                    // Scale
                    if (keys.Contains(Keys.W)) { selectedShape.ScaleFactor += ScaleStep; needsRedraw = true; }
                    if (keys.Contains(Keys.S)) { selectedShape.ScaleFactor = Math.Max(0.1f, selectedShape.ScaleFactor - ScaleStep); needsRedraw = true; }

                    // Translation
                    if (keys.Contains(Keys.J)) { selectedShape.TraslateX -= TranslationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.L)) { selectedShape.TraslateX += TranslationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.I)) { selectedShape.TraslateY += TranslationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.K)) { selectedShape.TraslateY -= TranslationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.U)) { selectedShape.TraslateZ -= TranslationStep; needsRedraw = true; }
                    if (keys.Contains(Keys.O)) { selectedShape.TraslateZ += TranslationStep; needsRedraw = true; }
                }
                else
                {
                    needsRedraw = true;
                }
            }

            if (needsRedraw) targetCanvas.Invalidate();
        }

        private void ApplyTransformationToPoint(Point3D point)
        {
            if (keys.Contains(Keys.J)) point.X -= TranslationStep;
            if (keys.Contains(Keys.L)) point.X += TranslationStep;
            if (keys.Contains(Keys.I)) point.Y += TranslationStep;
            if (keys.Contains(Keys.K)) point.Y -= TranslationStep;
            if (keys.Contains(Keys.U)) point.Z -= TranslationStep;
            if (keys.Contains(Keys.O)) point.Z += TranslationStep;

            if (keys.Contains(Keys.W)) { point.X *= 1.01f; point.Y *= 1.01f; point.Z *= 1.01f; }
            if (keys.Contains(Keys.S)) { point.X *= 0.99f; point.Y *= 0.99f; point.Z *= 0.99f; }
        }

        private void HandleDeleteKey(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Back || e.KeyCode == Keys.Delete)
            {
                var selected = sceneManager.Shapes.Find(s => s.IsSelected);
                if (selected != null)
                {
                    sceneManager.Shapes.Remove(selected);
                    sceneManager.SelectedVertexIndex = null;
                    sceneManager.SelectedEdge = null;
                    sceneManager.SelectedFace = null;

                    OnStatusChanged?.Invoke("Shape Deleted");
                    targetCanvas.Invalidate();
                }
            }
        }

        public static string GetControlsHelp()
        {
            return @"-------------------------------------------
    CONTROLS
-------------------------------------------

CAMERA:
   Arrows     Rotate Camera
   + / -      Zoom
   F1 - F5    Preset Views
   Home       Reset Camera

TRANSFORM OBJECT (Selected):
   W / S      Scale (Up/Down)
   J / L      Move X
   I / K      Move Y
   U / O      Move Z

   NumPad/Keys for Rotation:
   4 / 6      Rotate X
   8 / 2      Rotate Y
   A / D      Rotate Z

ACTIONS:
   Delete     Delete Selected Object
   F6         Show this Help";
        }
    }
}